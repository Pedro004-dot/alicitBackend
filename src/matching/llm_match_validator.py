#!/usr/bin/env python3
"""
ü§ñ VALIDADOR LLM PARA MATCHES DE ALTA QUALIDADE
Sistema de valida√ß√£o final para matches acima de 80% usando IA generativa
"""

import os
import json
from typing import Dict, Any, List, Tuple, Optional
import logging
from openai import OpenAI

logger = logging.getLogger(__name__)

class LLMMatchValidator:
    """
    üéØ Validador inteligente para matches de alta qualidade
    
    Analisa matches acima de 80% usando LLM para determinar se realmente
    fazem sentido do ponto de vista de neg√≥cio e compet√™ncia empresarial.
    """
    
    def __init__(self):
        """Inicializar o validador com configura√ß√µes"""
        self.openai_client = None
        self._setup_llm()
        
        # Thresholds para valida√ß√£o
        self.HIGH_SCORE_THRESHOLD = 0.80  # Acima de 80% vai para valida√ß√£o LLM
        self.LLM_CONFIDENCE_THRESHOLD = 0.75  # Confian√ßa m√≠nima do LLM para aprovar
        
    def _setup_llm(self):
        """Configurar cliente OpenAI"""
        try:
            api_key = os.getenv('OPENAI_API_KEY')
            if api_key:
                self.openai_client = OpenAI(api_key=api_key)
                logger.info("‚úÖ Cliente OpenAI configurado para valida√ß√£o LLM")
            else:
                logger.warning("‚ö†Ô∏è OPENAI_API_KEY n√£o encontrada - valida√ß√£o LLM desabilitada")
        except Exception as e:
            logger.error(f"‚ùå Erro ao configurar OpenAI: {e}")
    
    def should_validate_with_llm(self, score: float) -> bool:
        """Determina se o match precisa de valida√ß√£o LLM"""
        return score >= self.HIGH_SCORE_THRESHOLD and self.openai_client is not None
    
    def validate_match(
        self, 
        empresa_nome: str,
        empresa_descricao: str,
        licitacao_objeto: str,
        pncp_id: str,
        similarity_score: float
    ) -> Dict[str, Any]:
        """
        ü§ñ Valida√ß√£o inteligente de match usando LLM
        
        Returns:
            Dict com resultado da valida√ß√£o:
            {
                'is_valid': bool,
                'confidence': float,
                'reasoning': str,
                'recommendation': str,
                'llm_used': bool
            }
        """
        
        if not self.should_validate_with_llm(similarity_score):
            return {
                'is_valid': True,
                'confidence': similarity_score,
                'reasoning': f'Score {similarity_score:.1%} abaixo do threshold LLM ({self.HIGH_SCORE_THRESHOLD:.1%})',
                'recommendation': 'Aprovado sem valida√ß√£o LLM',
                'llm_used': False
            }
        
        if not self.openai_client:
            logger.warning("‚ö†Ô∏è LLM n√£o dispon√≠vel - aprovando match automaticamente")
            return {
                'is_valid': True,
                'confidence': similarity_score,
                'reasoning': 'LLM indispon√≠vel - valida√ß√£o autom√°tica',
                'recommendation': 'Aprovado por fallback',
                'llm_used': False
            }
        
        try:
            # Prompt especializado para valida√ß√£o de matches
            prompt = self._build_validation_prompt(
                empresa_nome, empresa_descricao, licitacao_objeto, pncp_id, similarity_score
            )
            
            response = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",  # Modelo otimizado para custo-efetividade
                messages=[
                    {
                        "role": "system", 
                        "content": self._get_system_prompt()
                    },
                    {
                        "role": "user", 
                        "content": prompt
                    }
                ],
                temperature=0.1,  # Baixa criatividade para an√°lise objetiva
                max_tokens=500,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            
            # Validar estrutura da resposta
            validation_result = self._parse_llm_response(result, similarity_score)
            
            logger.info(f"ü§ñ LLM valida√ß√£o: {empresa_nome} vs {pncp_id} = {validation_result['is_valid']} (conf: {validation_result['confidence']:.1%})")
            
            return validation_result
            
        except Exception as e:
            logger.error(f"‚ùå Erro na valida√ß√£o LLM: {e}")
            
            # Fallback: aprovar automaticamente em caso de erro
            return {
                'is_valid': True,
                'confidence': similarity_score * 0.9,  # Penalizar levemente por falha LLM
                'reasoning': f'Erro na valida√ß√£o LLM: {str(e)} - Aprovado por fallback',
                'recommendation': 'Verificar manualmente',
                'llm_used': False
            }
    
    def _get_system_prompt(self) -> str:
        """Prompt do sistema para o LLM"""
        return """Voc√™ √© um especialista em an√°lise de licita√ß√µes p√∫blicas brasileiras e compet√™ncias empresariais.

Sua tarefa √© validar se um match entre uma empresa e uma licita√ß√£o faz sentido do ponto de vista de neg√≥cio e capacidade t√©cnica.

CRIT√âRIOS DE AVALIA√á√ÉO:
1. **Compet√™ncia T√©cnica**: A empresa tem capacidade de executar o objeto da licita√ß√£o?
2. **√Årea de Atua√ß√£o**: O ramo de atividade da empresa √© compat√≠vel com o servi√ßo/produto licitado?
3. **Experi√™ncia Relevante**: A descri√ß√£o da empresa indica experi√™ncia no setor?
4. **Viabilidade Comercial**: Faz sentido comercial a empresa participar desta licita√ß√£o?

RESPONDA SEMPRE EM JSON com esta estrutura:
{
    "is_valid": boolean,
    "confidence": number (0.0 a 1.0),
    "reasoning": "explica√ß√£o detalhada da an√°lise",
    "recommendation": "RECOMENDADO | N√ÉO_RECOMENDADO | REVISAR_MANUALMENTE"
}

Seja rigoroso: prefira reprovar matches duvidosos a aprovar matches irrelevantes."""
    
    def _build_validation_prompt(
        self, 
        empresa_nome: str, 
        empresa_descricao: str, 
        licitacao_objeto: str, 
        pncp_id: str, 
        similarity_score: float
    ) -> str:
        """Constr√≥i o prompt de valida√ß√£o"""
        
        return f"""AN√ÅLISE DE MATCH PARA VALIDA√á√ÉO:

**EMPRESA:**
- Nome: {empresa_nome}
- Descri√ß√£o: {empresa_descricao}

**LICITA√á√ÉO:**
- PNCP ID: {pncp_id}
- Objeto: {licitacao_objeto}

**SCORE SEM√ÇNTICO:** {similarity_score:.1%}

PERGUNTA: Esta empresa tem compet√™ncia e capacidade real para executar este objeto licitado? 
O match faz sentido do ponto de vista de neg√≥cio e adequa√ß√£o t√©cnica?

Analise cuidadosamente se h√° compatibilidade real entre:
- As compet√™ncias/experi√™ncia da empresa
- Os requisitos t√©cnicos da licita√ß√£o
- A viabilidade comercial do match

Responda em JSON conforme especificado."""
    
    def _parse_llm_response(self, llm_result: Dict, original_score: float) -> Dict[str, Any]:
        """Parseia e valida a resposta do LLM"""
        
        try:
            is_valid = llm_result.get('is_valid', False)
            confidence = float(llm_result.get('confidence', 0.0))
            reasoning = llm_result.get('reasoning', 'Sem justificativa fornecida')
            recommendation = llm_result.get('recommendation', 'REVISAR_MANUALMENTE')
            
            # Aplicar threshold de confian√ßa
            if confidence < self.LLM_CONFIDENCE_THRESHOLD:
                is_valid = False
                reasoning += f" | Confian√ßa LLM ({confidence:.1%}) abaixo do m√≠nimo ({self.LLM_CONFIDENCE_THRESHOLD:.1%})"
            
            # Garantir que confian√ßa n√£o seja maior que score original
            confidence = min(confidence, original_score)
            
            return {
                'is_valid': is_valid,
                'confidence': confidence,
                'reasoning': reasoning,
                'recommendation': recommendation,
                'llm_used': True
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao parsear resposta LLM: {e}")
            
            return {
                'is_valid': False,
                'confidence': 0.0,
                'reasoning': f'Erro ao processar resposta LLM: {str(e)}',
                'recommendation': 'REVISAR_MANUALMENTE',
                'llm_used': True
            }
    
    def validate_matches_batch(self, matches: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Valida m√∫ltiplos matches em lote
        
        Args:
            matches: Lista de dicts com campos:
                - empresa_nome, empresa_descricao
                - licitacao_objeto, pncp_id  
                - score_similaridade
        
        Returns:
            Lista de matches com valida√ß√£o LLM aplicada
        """
        
        validated_matches = []
        llm_validations_count = 0
        
        for match in matches:
            try:
                score = float(match.get('score_similaridade', 0))
                
                # Aplicar valida√ß√£o LLM se necess√°rio
                validation = self.validate_match(
                    empresa_nome=match.get('empresa_nome', ''),
                    empresa_descricao=match.get('empresa_descricao', ''),
                    licitacao_objeto=match.get('licitacao_objeto', ''),
                    pncp_id=match.get('pncp_id', ''),
                    similarity_score=score
                )
                
                # Adicionar resultado da valida√ß√£o ao match
                enhanced_match = match.copy()
                enhanced_match.update({
                    'llm_validation': validation,
                    'final_score': validation['confidence'],
                    'is_recommended': validation['is_valid']
                })
                
                # S√≥ adicionar √† lista se for v√°lido
                if validation['is_valid']:
                    validated_matches.append(enhanced_match)
                else:
                    logger.info(f"üö´ Match rejeitado pela valida√ß√£o LLM: {match.get('empresa_nome')} vs {match.get('pncp_id')}")
                
                if validation['llm_used']:
                    llm_validations_count += 1
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao validar match: {e}")
                # Em caso de erro, incluir o match original sem valida√ß√£o
                validated_matches.append(match)
        
        logger.info(f"ü§ñ Valida√ß√£o LLM: {llm_validations_count} matches analisados, {len(validated_matches)}/{len(matches)} aprovados")
        
        return validated_matches


# Inst√¢ncia global do validador
llm_validator = LLMMatchValidator()


def validate_high_score_match(
    empresa_nome: str,
    empresa_descricao: str, 
    licitacao_objeto: str,
    pncp_id: str,
    similarity_score: float
) -> Dict[str, Any]:
    """
    üéØ Fun√ß√£o de conveni√™ncia para validar um match individual
    
    Wrapper around LLMMatchValidator.validate_match()
    """
    return llm_validator.validate_match(
        empresa_nome, empresa_descricao, licitacao_objeto, 
        pncp_id, similarity_score
    )


if __name__ == "__main__":
    # Teste com exemplos reais ruins
    validator = LLMMatchValidator()
    
    # Exemplo 1: Software vs Manuten√ß√£o de Ve√≠culos (deveria ser rejeitado)
    result1 = validator.validate_match(
        empresa_nome="InfinitiFy",
        empresa_descricao="Empresa especialista no fornecimento de softwares, sistemas de redes, banco de dados, inteligencia artificial.",
        licitacao_objeto="Registro de pre√ßos para a presta√ß√£o de servi√ßos de manuten√ß√£o em ve√≠culos leves, vans, minivans, micro-√¥nibus e caminh√µes, sendo: mec√¢nica, el√©trica e eletr√¥nica, funilaria, lanternagem e pintura",
        pncp_id="87613196000178-1-000045/2025",
        similarity_score=0.892
    )
    
    print("üß™ TESTE 1 - Software vs Ve√≠culos:")
    print(f"‚úÖ V√°lido: {result1['is_valid']}")
    print(f"üìä Confian√ßa: {result1['confidence']:.1%}")
    print(f"üí≠ Racioc√≠nio: {result1['reasoning']}")
    print(f"üéØ Recomenda√ß√£o: {result1['recommendation']}")
    print()
    
    # Exemplo 2: Match que deveria ser aprovado
    result2 = validator.validate_match(
        empresa_nome="TechSoft Solutions",
        empresa_descricao="Empresa especializada em desenvolvimento de software de gest√£o p√∫blica, sistemas de ponto eletr√¥nico e controle de acesso, com experi√™ncia em implementa√ß√£o de solu√ß√µes tecnol√≥gicas para √≥rg√£os p√∫blicos.",
        licitacao_objeto="Contrata√ß√£o de empresa especializada na presta√ß√£o de servi√ßos de implanta√ß√£o de sistema de gest√£o administrativa de ponto eletr√¥nico facial e controle de acesso de funcion√°rios",
        pncp_id="19904298000192-1-000012/2025",
        similarity_score=0.850
    )
    
    print("üß™ TESTE 2 - Software vs Software (match bom):")
    print(f"‚úÖ V√°lido: {result2['is_valid']}")
    print(f"üìä Confian√ßa: {result2['confidence']:.1%}")
    print(f"üí≠ Racioc√≠nio: {result2['reasoning']}")
    print(f"üéØ Recomenda√ß√£o: {result2['recommendation']}") 