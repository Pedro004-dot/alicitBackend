#!/usr/bin/env python3
"""
üß™ Teste simplificado do novo parser HTML do ComprasNet
Valida a extra√ß√£o de dados usando tags HTML ao inv√©s de regex
"""

import sys
import os
import re
from datetime import datetime
from bs4 import BeautifulSoup
from typing import List, Dict, Any, Optional

def parse_html_licitacao_data(data_cell, form_name: str, block_number: int) -> Optional[Dict[str, Any]]:
    """
    üéØ M√âTODO NOVO: Parse estruturado baseado em tags HTML
    Extrai dados diretamente da estrutura HTML do ComprasNet
    """
    try:
        # Extrair texto limpo da c√©lula
        cell_text = data_cell.get_text(separator='\n', strip=True)
        
        # Tamb√©m processar HTML para extrair links e elementos estruturados
        cell_html = str(data_cell)
        
        # 1Ô∏è‚É£ EXTRAIR ENTIDADE/ORGANIZA√á√ÉO: Primeiras linhas em <b>
        organization_lines = []
        bold_tags = data_cell.find_all('b')
        
        # Pegar apenas o primeiro <b> que cont√©m a organiza√ß√£o
        first_bold = bold_tags[0] if bold_tags else None
        if first_bold:
            # O primeiro <b> cont√©m as linhas organizacionais separadas por <br>
            org_text = first_bold.get_text(separator='\n', strip=True)
            org_lines = [line.strip() for line in org_text.split('\n') if line.strip()]
            
            # Filtrar linhas que cont√™m "C√≥digo da UASG"
            org_lines_filtered = [line for line in org_lines if 'C√≥digo da UASG' not in line]
            
            if org_lines_filtered:
                # Se h√° m√∫ltiplas linhas, pegar a √∫ltima (entidade espec√≠fica)
                entity_name = org_lines_filtered[-1]
                # Tamb√©m extrair minist√©rio e √≥rg√£o para hierarquia
                ministry = org_lines_filtered[0] if len(org_lines_filtered) >= 1 else ""
                organ = org_lines_filtered[1] if len(org_lines_filtered) >= 2 else ""
            else:
                entity_name = "Entidade n√£o identificada"
                ministry = ""
                organ = ""
        else:
            entity_name = "Entidade n√£o identificada"
            ministry = ""
            organ = ""
        
        # 2Ô∏è‚É£ EXTRAIR C√ìDIGO UASG
        uasg_match = re.search(r'C√≥digo da UASG\s*:?\s*(\d+)', cell_text, re.IGNORECASE)
        uasg = uasg_match.group(1) if uasg_match else ''
        
        # 3Ô∏è‚É£ EXTRAIR N√öMERO DO PREG√ÉO
        pregao_match = re.search(r'Preg√£o Eletr√¥nico N¬∫\s*(\d+)/(\d+)', cell_text, re.IGNORECASE)
        
        # Construir external_id
        if pregao_match and uasg:
            pregao_num = pregao_match.group(1)
            pregao_ano = pregao_match.group(2)
            external_id = f"comprasnet_{uasg}_{pregao_num}_{pregao_ano}"
        else:
            external_id = f"comprasnet_{form_name}_{block_number}_{int(datetime.now().timestamp())}"
        
        # 4Ô∏è‚É£ EXTRAIR OBJETO
        objeto_match = re.search(r'Objeto\s*:\s*(.+?)(?=\nEdital|\nEndere√ßo|\nTelefone|\nEntrega|$)', cell_text, re.IGNORECASE | re.DOTALL)
        if objeto_match:
            objeto = objeto_match.group(1).strip()
            # Limpar "Objeto: " duplicado se existir
            objeto = re.sub(r'^Objeto\s*:\s*', '', objeto, flags=re.IGNORECASE)
        else:
            objeto = f"Preg√£o Eletr√¥nico ComprasNet #{block_number}"
        
        # 5Ô∏è‚É£ EXTRAIR DATAS
        # Data do edital (publica√ß√£o)
        edital_match = re.search(r'Edital a partir de\s*:\s*(.+?)(?=\n|$)', cell_text, re.IGNORECASE)
        edital_date_str = edital_match.group(1).strip() if edital_match else ''
        
        # Data de entrega da proposta (encerramento)
        entrega_match = re.search(r'Entrega da Proposta\s*:\s*(.+?)(?=\n|$)', cell_text, re.IGNORECASE)
        entrega_date_str = entrega_match.group(1).strip() if entrega_match else ''
        
        # Processar datas estruturadas
        publication_date = None
        closing_date = None
        opening_date = None
        
        # Extrair data de publica√ß√£o (mesmo que edital)
        if edital_date_str:
            # Regex para extrair primeira data do formato DD/MM/YYYY
            pub_date_match = re.search(r'(\d{2}/\d{2}/\d{4})', edital_date_str)
            if pub_date_match:
                publication_date = pub_date_match.group(1)
                opening_date = publication_date  # Data de abertura = data de publica√ß√£o
        
        # Extrair data de encerramento
        if entrega_date_str:
            # Regex para extrair data do formato DD/MM/YYYY
            close_date_match = re.search(r'(\d{2}/\d{2}/\d{4})', entrega_date_str)
            if close_date_match:
                closing_date = close_date_match.group(1)
        
        # 6Ô∏è‚É£ EXTRAIR ENDERE√áO E UF
        endereco_match = re.search(r'Endere√ßo\s*:\s*(.+?)(?=\nTelefone|\nFax|\nEntrega|$)', cell_text, re.IGNORECASE | re.DOTALL)
        endereco = endereco_match.group(1).strip() if endereco_match else ""
        
        # Extrair UF do endere√ßo - padr√£o: - CIDADE (UF)
        # Buscar o padr√£o no final do endere√ßo
        uf_match = re.search(r'-\s*([A-Z√Å√â√ç√ì√ö√Ç√ä√é√î√õ√Ä√à√å√í√ô√É√ï√á][A-Za-z√°√©√≠√≥√∫√¢√™√Æ√¥√ª√†√®√¨√≤√π√£√µ√ß\s]+?)\s*\(([A-Z]{2})\)\s*$', endereco)
        if uf_match:
            cidade = uf_match.group(1).strip()
            uf_sigla = uf_match.group(2)
        else:
            # Fallback: buscar apenas (UF) no final
            uf_fallback = re.search(r'\(([A-Z]{2})\)\s*$', endereco)
            if uf_fallback:
                uf_sigla = uf_fallback.group(1)
                # Tentar extrair cidade da parte anterior ao (UF)
                # Buscar padr√£o - espa√ßos - CIDADE - espa√ßos - (UF)
                cidade_match = re.search(r'-\s*([A-Z√Å√â√ç√ì√ö√Ç√ä√é√î√õ√Ä√à√å√í√ô√É√ï√á][A-Za-z√°√©√≠√≥√∫√¢√™√Æ√¥√ª√†√®√¨√≤√π√£√µ√ß\s]*?)\s*\([A-Z]{2}\)', endereco)
                if cidade_match:
                    cidade = cidade_match.group(1).strip()
                else:
                    # Se n√£o encontrar, buscar qualquer palavra mai√∫scula antes do (UF)
                    cidade_alt = re.search(r'([A-Z√Å√â√ç√ì√ö√Ç√ä√é√î√õ√Ä√à√å√í√ô√É√ï√á]+)\s*\([A-Z]{2}\)', endereco)
                    cidade = cidade_alt.group(1).strip() if cidade_alt else ""
            else:
                cidade = ""
                uf_sigla = ""
        
        # 7Ô∏è‚É£ EXTRAIR TELEFONE
        telefone_match = re.search(r'Telefone\s*:\s*(.+?)(?=\nFax|\nEntrega|$)', cell_text, re.IGNORECASE)
        telefone = telefone_match.group(1).strip() if telefone_match else ""
        
        # 8Ô∏è‚É£ EXTRAIR PAR√ÇMETROS PARA BUSCA DE ITENS
        bid_params = None
        if uasg and pregao_match:
            numprp = f"{pregao_match.group(1)}{pregao_match.group(2)}"
            bid_params = {
                'coduasg': uasg,
                'modprp': '5',  # Preg√£o Eletr√¥nico
                'numprp': numprp,
                'ano': pregao_match.group(2)
            }
        
        # 9Ô∏è‚É£ EXTRAIR LINKS DO HIST√ìRICO E ITENS
        historico_link = None
        itens_link = None
        
        # Buscar link do hist√≥rico
        historico_a = data_cell.find('a', string=re.compile(r'Hist√≥rico de eventos', re.IGNORECASE))
        if historico_a and historico_a.get('onclick'):
            onclick_text = historico_a.get('onclick')
            link_match = re.search(r"'([^']+)'", onclick_text)
            if link_match:
                historico_link = link_match.group(1)
        
        # Buscar bot√£o de itens
        itens_button = data_cell.find('input', {'value': 'Itens e Download'})
        if itens_button and itens_button.get('onclick'):
            onclick_text = itens_button.get('onclick')
            link_match = re.search(r"'([^']+)'", onclick_text)
            if link_match:
                itens_link = link_match.group(1)
        
        # üìã CONSTRUIR DADOS ESTRUTURADOS
        raw_data = {
            # IDs e identificadores √∫nicos
            'external_id': external_id,
            'uasg': uasg,
            'pregao_numero': pregao_match.group(1) if pregao_match else '',
            'pregao_ano': pregao_match.group(2) if pregao_match else '',
            
            # Informa√ß√µes organizacionais
            'ministry': ministry,                    # Minist√©rio/Governo
            'organ': organ,                         # √ìrg√£o/Secretaria
            'entity_name': entity_name,             # Entidade espec√≠fica
            
            # Dados da licita√ß√£o
            'object_description': objeto,
            'modality': 'PREGAO_ELETRONICO',
            'status': 'PUBLISHED',
            
            # Localiza√ß√£o
            'endereco': endereco,
            'cidade': cidade,
            'uf': uf_sigla,                        # Estado (importante para filtros)
            'telefone': telefone,
            
            # Datas importantes (formato YYYY-MM-DD)
            'publication_date': publication_date,    # Data de publica√ß√£o
            'opening_date': opening_date,           # Data de abertura (mesmo que publica√ß√£o)
            'closing_date': closing_date,           # Data de fechamento/entrega
            
            # Datas em formato original (para debug)
            'edital_date_str': edital_date_str,     # Data de publica√ß√£o original
            'entrega_date_str': entrega_date_str,   # Data de fechamento original
            
            # Links e par√¢metros
            'bid_params': bid_params,
            'historico_link': historico_link,
            'itens_link': itens_link,
            
            # Metadados
            'form_name': form_name,
            'extracted_at': datetime.now().isoformat(),
            'extraction_method': 'html_parser',
            'raw_html': cell_html[:1000]  # Primeiros 1000 chars do HTML para debug
        }
        
        return raw_data
        
    except Exception as e:
        print(f"‚ùå Erro no parse HTML da licita√ß√£o: {e}")
        return None

def find_advanced_licitacao_blocks(soup: BeautifulSoup) -> List[Dict[str, Any]]:
    """
    üîç M√âTODO AVAN√áADO: Encontrar blocos de licita√ß√µes usando parser HTML baseado em tags
    Parser HTML direto das estruturas <form> para m√°xima precis√£o
    """
    try:
        print("üîç Buscando licita√ß√µes usando parser HTML baseado em tags...")
        
        # Buscar todos os forms que cont√™m licita√ß√µes
        form_blocks = soup.find_all('form', {'method': 'post'})
        print(f"üìã Forms encontrados: {len(form_blocks)}")
        
        licitacao_data_list = []
        
        for i, form in enumerate(form_blocks):
            try:
                # Cada form representa uma licita√ß√£o
                form_name = form.get('name', f'Form{i+1}')
                print(f"üîç Processando form {i+1}: {form_name}")
                
                # Buscar a tabela dentro do form que cont√©m os dados
                table = form.find('table', {'class': 'td'})
                if not table:
                    print(f"‚ö†Ô∏è Form {i+1}: Tabela com class 'td' n√£o encontrada")
                    # Debug: mostrar todas as tabelas encontradas
                    all_tables = form.find_all('table')
                    print(f"   Debug: {len(all_tables)} tabelas encontradas no form")
                    for j, t in enumerate(all_tables):
                        print(f"   Tabela {j}: classes={t.get('class', [])}")
                    continue
                
                # Buscar a c√©lula com classe 'tex3' que cont√©m os dados da licita√ß√£o
                # Primeira tentativa: buscar por classe tex3 na c√©lula
                data_cell = table.find('td', {'class': 'tex3'})
                
                # Segunda tentativa: buscar por tr com classe tex3 e pegar sua c√©lula
                if not data_cell:
                    tr_tex3 = table.find('tr', {'class': 'tex3'})
                    if tr_tex3:
                        data_cell = tr_tex3.find('td')
                
                # Terceira tentativa: buscar pela segunda c√©lula (que geralmente tem os dados)
                if not data_cell:
                    all_cells = table.find_all('td')
                    if len(all_cells) >= 2:
                        # A segunda c√©lula geralmente tem os dados da licita√ß√£o
                        data_cell = all_cells[1]
                        print(f"‚úÖ Form {i+1}: Usando segunda c√©lula como dados")
                    else:
                        print(f"‚ö†Ô∏è Form {i+1}: N√£o h√° c√©lulas suficientes")
                        continue
                
                print(f"‚úÖ Form {i+1}: C√©lula de dados encontrada")
                
                # Extrair dados estruturados do HTML
                licitacao_data = parse_html_licitacao_data(data_cell, form_name, i+1)
                
                if licitacao_data:
                    licitacao_data_list.append(licitacao_data)
                    print(f"‚úÖ Licita√ß√£o {i+1} extra√≠da via HTML: {licitacao_data.get('external_id', 'N/A')}")
                else:
                    print(f"‚ö†Ô∏è Form {i+1}: Dados n√£o extra√≠dos")
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao processar form {i+1}: {e}")
                continue
        
        print(f"üéØ Parser HTML encontrou {len(licitacao_data_list)} licita√ß√µes v√°lidas")
        return licitacao_data_list
        
    except Exception as e:
        print(f"‚ùå Erro no parser HTML: {e}")
        return []

def test_html_parser():
    """Testar o parser HTML com dados reais do ComprasNet"""
    
    # Sample HTML baseado no exemplo real fornecido
    sample_html = """
    <form method="post" name="Form1">
        <a name="F1">&nbsp;</a>
        <table border="0" width="100%" class="td" cellpadding="1" cellspacing="1">
            <tbody>
                <tr class="mensagem"><td>1</td></tr>
                <tr bgcolor="#FFFFFF" class="tex3">
                    <td>
                        <b>MINIST√âRIO DA SA√öDE<br>FUNDA√á√ÉO OSWALDO CRUZ<br>Instituto de Tecnologia em Imunobiologicos Bio Manguinhos<br>C√≥digo da UASG: 254445<br></b>
                        <br>
                        <b>Preg√£o Eletr√¥nico N¬∫ 90169/2025<span class="mensagem"> - (Lei N¬∫ 14.133/2021)</span></b>
                        <br>
                        <b>Objeto:</b>&nbsp;Objeto: Preg√£o Eletr√¥nico -  Aquisi√ß√£o de itens da marca ABB.
                        <br>
                        <b>Edital a partir de:</b>&nbsp;10/07/2025 das 08:00 √†s 12:00 Hs e das 13:00 √†s 17:59 Hs
                        <br>
                        <b>Endere√ßo:</b>&nbsp;Avenida Brasil, 4365 - Manguinhos - Rio de Janeiro (RJ)
                        <br>
                        <b>Telefone:</b>&nbsp;(0xx21) 38829334
                        <br>
                        <b>Fax:</b>&nbsp;(0xx21)               
                        <br>
                        <b>Entrega da Proposta:</b>&nbsp;10/07/2025 √†s 08:00Hs
                        <br><br>
                        <input type="hidden" name="origem" value="2">
                        <a href="#F1" name="hist_eventos" class="legenda" onclick="javascript:visualizarHistoricoEventos(document.Form1,'?coduasg=254445&amp;modprp=5&amp;numprp=901692025');" title="Visualizar hist√≥rico de eventos publicados para a licita√ß√£o">Hist√≥rico de eventos publicados...</a>
                        <br><br>
                        <input type="button" name="itens" value="Itens e Download" class="texField2" onclick="javascript:VisualizarItens(document.Form1,'?coduasg=254445&amp;modprp=5&amp;numprp=901692025');" onmouseover="window.status='Itens da Licita√ß√£o e Download do Edital';return true;" title="Clique para ver os itens ou fazer o Download do Edital">
                    </td>
                </tr>
            </tbody>
        </table>
    </form>
    
    <form method="post" name="Form9">
        <a name="F9">&nbsp;</a>
        <table border="0" width="100%" class="td" cellpadding="1" cellspacing="1">
            <tbody>
                <tr class="mensagem"><td>9</td></tr>
                <tr bgcolor="#FFFFFF" class="tex3">
                    <td>
                        <b>GOVERNO DO DISTRITO FEDERAL - GDF<br>Secretaria de Estado de Sa√∫de do Distrito Federal<br>C√≥digo da UASG: 926119<br></b>
                        <br>
                        <b>Preg√£o Eletr√¥nico N¬∫ 90139/2025<span class="mensagem"> - (Lei N¬∫ 14.133/2021)</span></b>
                        <br>
                        <b>Objeto:</b>&nbsp;Objeto: Preg√£o Eletr√¥nico -  Aquisi√ß√£o de insumos necess√°rios para a realiza√ß√£o da t√©cnica de MAC-ELISA empregada no diagn√≥stico sorol√≥gico de dengue, zika, chikungunya, febre amarela, agravos esses que se constituem em s√©rios problemas de sa√∫de p√∫blica em sistema de registro de pre√ßos, conforme especifica√ß√µes e quantitativos constantes no Anexo I do Edital.
                        <br>
                        <b>Edital a partir de:</b>&nbsp;10/07/2025 das 08:00 √†s 12:00 Hs e das 13:00 √†s 17:59 Hs
                        <br>
                        <b>Endere√ßo:</b>&nbsp;Srtvn Qd 701, Conj c Ed. Po 700                                                      -                                          - BRAS√çLIA                                 (DF)
                        <br>
                        <b>Telefone:</b>&nbsp;         
                        <br>
                        <b>Fax:</b>&nbsp;               
                        <br>
                        <b>Entrega da Proposta:</b>&nbsp;10/07/2025 √†s 08:00Hs
                        <br><br>
                        <input type="hidden" name="origem" value="2">
                        <a href="#F9" name="hist_eventos" class="legenda" onclick="javascript:visualizarHistoricoEventos(document.Form9,'?coduasg=926119&amp;modprp=5&amp;numprp=901392025');" title="Visualizar hist√≥rico de eventos publicados para a licita√ß√£o">Hist√≥rico de eventos publicados...</a>
                        <br><br>
                        <input type="button" name="itens" value="Itens e Download" class="texField2" onclick="javascript:VisualizarItens(document.Form9,'?coduasg=926119&amp;modprp=5&amp;numprp=901392025');" onmouseover="window.status='Itens da Licita√ß√£o e Download do Edital';return true;" title="Clique para ver os itens ou fazer o Download do Edital">
                    </td>
                </tr>
            </tbody>
        </table>
    </form>
    """
    
    print("üß™ Testando novo parser HTML do ComprasNet...")
    print("="*60)
    
    # Criar soup do HTML de exemplo
    soup = BeautifulSoup(sample_html, 'html.parser')
    
    # Testar o novo parser
    licitacao_data_list = find_advanced_licitacao_blocks(soup)
    
    print(f"üìä Licita√ß√µes encontradas: {len(licitacao_data_list)}")
    print("="*60)
    
    for i, licitacao_data in enumerate(licitacao_data_list, 1):
        print(f"\nüèõÔ∏è LICITA√á√ÉO {i}:")
        print(f"   üÜî ID: {licitacao_data.get('external_id', 'N/A')}")
        print(f"   üèõÔ∏è Minist√©rio: {licitacao_data.get('ministry', 'N/A')}")
        print(f"   üè¢ √ìrg√£o: {licitacao_data.get('organ', 'N/A')}")
        print(f"   üè≠ Entidade: {licitacao_data.get('entity_name', 'N/A')}")
        print(f"   üìã UASG: {licitacao_data.get('uasg', 'N/A')}")
        print(f"   üìÑ Preg√£o: {licitacao_data.get('pregao_numero', 'N/A')}/{licitacao_data.get('pregao_ano', 'N/A')}")
        print(f"   üéØ Objeto: {licitacao_data.get('object_description', 'N/A')[:100]}...")
        print(f"   üìÖ Publica√ß√£o: {licitacao_data.get('publication_date', 'N/A')}")
        print(f"   üöÄ Abertura: {licitacao_data.get('opening_date', 'N/A')}")
        print(f"   ‚è∞ Encerramento: {licitacao_data.get('closing_date', 'N/A')}")
        print(f"   üìç Endere√ßo: {licitacao_data.get('endereco', 'N/A')}")
        print(f"   üèôÔ∏è Cidade/UF: {licitacao_data.get('cidade', 'N/A')}/{licitacao_data.get('uf', 'N/A')}")
        print(f"   üìû Telefone: {licitacao_data.get('telefone', 'N/A')}")
        print(f"   üîó Hist√≥rico: {licitacao_data.get('historico_link', 'N/A')}")
        print(f"   üì¶ Itens: {licitacao_data.get('itens_link', 'N/A')}")
        print(f"   üîß Params: {licitacao_data.get('bid_params', 'N/A')}")
        print(f"   ‚öôÔ∏è M√©todo: {licitacao_data.get('extraction_method', 'N/A')}")
        print(f"   üïê Extra√≠do: {licitacao_data.get('extracted_at', 'N/A')}")
        
        # Mostrar primeiros 200 chars do HTML raw
        raw_html = licitacao_data.get('raw_html', '')
        if raw_html:
            print(f"   üîç HTML (200 chars): {raw_html[:200]}...")
    
    print("\n" + "="*60)
    print("‚úÖ Teste conclu√≠do!")
    
    # Validar se os dados essenciais foram extra√≠dos
    if licitacao_data_list:
        success_count = 0
        for licitacao in licitacao_data_list:
            if (licitacao.get('external_id') and 
                licitacao.get('entity_name') and 
                licitacao.get('uasg') and 
                licitacao.get('object_description')):
                success_count += 1
        
        print(f"üìà Taxa de sucesso: {success_count}/{len(licitacao_data_list)} ({success_count/len(licitacao_data_list)*100:.1f}%)")
        
        if success_count == len(licitacao_data_list):
            print("üéâ TODOS os dados essenciais foram extra√≠dos com sucesso!")
        else:
            print(f"‚ö†Ô∏è {len(licitacao_data_list) - success_count} licita√ß√µes com dados incompletos")
    else:
        print("‚ùå Nenhuma licita√ß√£o foi extra√≠da")

if __name__ == "__main__":
    test_html_parser()